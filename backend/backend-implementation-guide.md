# Backend Implementation Guide: Supabase Edge Functions

This guide provides detailed implementation steps and code examples for setting up the Supabase Edge Functions backend for CosmiFi.

## Prerequisites

1. Node.js 18+ installed
2. Supabase CLI installed
3. Pinata account with API keys
4. Basic knowledge of TypeScript and Deno runtime

## Step 1: Initialize Supabase Project

```bash
# Install Supabase CLI
npm install -g supabase

# Login to Supabase
supabase login

# Initialize new project
supabase init

# Link to existing project or create new
supabase link --project-ref YOUR_PROJECT_ID
```

## Step 2: Backend Directory Setup

Create the backend directory structure:

```bash
mkdir -p backend/supabase/functions/_shared/{middleware,utils,types}
mkdir -p backend/supabase/functions/{auth,profiles,designs,webhook}
mkdir -p backend/supabase/migrations
```

## Step 3: Configuration Files

### package.json
```json
{
  "name": "cosmifi-backend",
  "version": "1.0.0",
  "scripts": {
    "dev": "supabase start",
    "deploy": "supabase functions deploy",
    "test": "deno test --allow-net"
  },
  "devDependencies": {
    "@types/node": "^18.0.0",
    "supabase": "^1.0.0"
  }
}
```

### tsconfig.json
```json
{
  "compilerOptions": {
    "target": "es2020",
    "lib": ["es2020", "dom"],
    "module": "esnext",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "allowJs": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true
  },
  "include": [
    "supabase/functions/**/*"
  ],
  "exclude": [
    "node_modules"
  ]
}
```

### supabase/config.toml
```toml
[api]
enabled = true
port = 54321
schemas = ["public", "graphql_public"]
extra_search_path = ["public", "extensions"]
max_rows = 1000

[db]
port = 54322
shadow_port = 54320
major_version = 15

[studio]
enabled = true
port = 54323
api_url = "http://localhost:54321"

[inbucket]
enabled = true
port = 54324
smtp_port = 54325
pop3_port = 54326

[storage]
enabled = true
file_size_limit = "50MiB"

[auth]
enabled = true
site_url = "http://localhost:3000"
additional_redirect_urls = ["https://localhost:3000"]
jwt_expiry = 3600

[edge_functions]
enabled = true
port = 54324
verify_jwt = false
```

## Step 4: Database Schema

Create migration file: `supabase/migrations/20240101000001_initial_schema.sql`

```sql
-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Profiles table for user information
CREATE TABLE profiles (
  wallet_address TEXT PRIMARY KEY,
  username TEXT,
  bio TEXT,
  avatar_url TEXT,
  social_links JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Designs table for NFT design data
CREATE TABLE designs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  token_id BIGINT UNIQUE,
  owner_address TEXT NOT NULL,
  metadata_cid TEXT,
  name TEXT,
  description TEXT,
  category TEXT,
  tags TEXT[] DEFAULT '{}',
  version TEXT DEFAULT 'v1.0',
  license TEXT DEFAULT 'CC-BY-4.0',
  preview_cid TEXT,
  cad_zip_cid TEXT,
  status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'uploaded', 'metadata_ready', 'minted')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  minted_at TIMESTAMP WITH TIME ZONE
);

-- Create indexes for performance
CREATE INDEX idx_designs_owner_address ON designs(owner_address);
CREATE INDEX idx_designs_status ON designs(status);
CREATE INDEX idx_designs_category ON designs(category);
CREATE INDEX idx_designs_tags ON designs USING GIN(tags);

-- Enable RLS
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE designs ENABLE ROW LEVEL SECURITY;

-- Create policies for profiles
CREATE POLICY "Public profiles are viewable by everyone" ON profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile" ON profiles FOR INSERT WITH CHECK (auth.jwt() ->> 'wallet_address' = wallet_address);
CREATE POLICY "Users can update own profile" ON profiles FOR UPDATE USING (auth.jwt() ->> 'wallet_address' = wallet_address);

-- Create policies for designs
CREATE POLICY "Designs are viewable by everyone" ON designs FOR SELECT USING (true);
CREATE POLICY "Users can insert their own designs" ON designs FOR INSERT WITH CHECK (auth.jwt() ->> 'wallet_address' = owner_address);
CREATE POLICY "Users can update own designs" ON designs FOR UPDATE USING (auth.jwt() ->> 'wallet_address' = owner_address);

-- Function to automatically update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers to automatically update updated_at
CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON profiles FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_designs_updated_at BEFORE UPDATE ON designs FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

## Step 5: Shared Utilities

### supabase/functions/_shared/types/index.ts
```typescript
export interface UserProfile {
  wallet_address: string
  username?: string
  bio?: string
  avatar_url?: string
  social_links?: Record<string, string>
  created_at: string
  updated_at: string
}

export interface Design {
  id: number
  token_id?: number
  owner_address: string
  metadata_cid?: string
  name?: string
  description?: string
  category?: string
  tags?: string[]
  version?: string
  license?: string
  preview_cid?: string
  cad_zip_cid?: string
  status: 'draft' | 'uploaded' | 'metadata_ready' | 'minted'
  created_at: string
  updated_at: string
  minted_at?: string
}

export interface NFTMetadata {
  name: string
  description: string
  image: string // IPFS URL
  cad_zip: string // IPFS URL
  creator: string // Wallet address
  category: string
  version: string
  tags: string[]
  license: string
  attributes?: Array<{
    trait_type: string
    value: string
  }>
}

export interface PinataResponse {
  IpfsHash: string
  PinSize: number
  Timestamp: string
}

export interface JWTPayload {
  wallet_address: string
  exp: number
  iat: number
}
```

### supabase/functions/_shared/utils/jwt.ts
```typescript
import { create } from 'https://deno.land/x/djwt@v2.8/mod.ts'
import { JWTPayload } from '../types/index.ts'

const JWT_SECRET = Deno.env.get('JWT_SECRET')!

export function generateJWT(payload: Omit<JWTPayload, 'exp' | 'iat'>): string {
  const now = Math.floor(Date.now() / 1000)
  const jwtPayload: JWTPayload = {
    ...payload,
    iat: now,
    exp: now + 24 * 60 * 60 // 24 hours
  }
  
  return create({ alg: 'HS512', typ: 'JWT' }, jwtPayload, JWT_SECRET)
}

export async function verifyJWT(token: string): Promise<JWTPayload> {
  // Implementation would go here for JWT verification
  // This is a placeholder - you'd use a proper JWT verification library
  throw new Error('JWT verification not implemented')
}
```

### supabase/functions/_shared/utils/ipfs.ts
```typescript
import { PinataResponse } from '../types/index.ts'

const PINATA_API_KEY = Deno.env.get('PINATA_API_KEY')!
const PINATA_SECRET_KEY = Deno.env.get('PINATA_SECRET_KEY')!

export async function pinFileToIPFS(file: File, name?: string): Promise<PinataResponse> {
  const formData = new FormData()
  formData.append('file', file)
  
  if (name) {
    const options = JSON.stringify({
      pinataMetadata: { name }
    })
    formData.append('pinataOptions', options)
  }
  
  const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
    method: 'POST',
    headers: {
      'pinata_api_key': PINATA_API_KEY,
      'pinata_secret_api_key': PINATA_SECRET_KEY
    },
    body: formData
  })
  
  if (!response.ok) {
    const error = await response.text()
    throw new Error(`IPFS upload failed: ${error}`)
  }
  
  return response.json()
}

export async function pinJSONToIPFS(json: any, name?: string): Promise<PinataResponse> {
  const response = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'pinata_api_key': PINATA_API_KEY,
      'pinata_secret_api_key': PINATA_SECRET_KEY
    },
    body: JSON.stringify({
      pinataContent: json,
      pinataMetadata: name ? { name } : undefined
    })
  })
  
  if (!response.ok) {
    const error = await response.text()
    throw new Error(`IPFS JSON upload failed: ${error}`)
  }
  
  return response.json()
}
```

### supabase/functions/_shared/middleware/auth.ts
```typescript
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { JWTPayload } from '../types/index.ts'

const supabase = createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
)

export interface AuthenticatedRequest extends Request {
  user: {
    id: string
    user_metadata: {
      wallet_address: string
    }
  }
}

export async function authMiddleware(req: Request): Promise<Response | null> {
  const authHeader = req.headers.get('Authorization')
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return new Response(JSON.stringify({ error: 'Missing or invalid token' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json' }
    })
  }
  
  const token = authHeader.substring(7)
  const { data: { user }, error } = await supabase.auth.getUser(token)
  
  if (error || !user) {
    return new Response(JSON.stringify({ error: 'Invalid token' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json' }
    })
  }
  
  // Attach user info to request context
  (req as AuthenticatedRequest).user = user
  return null // Continue processing
}
```

## Step 6: Core Edge Functions

### supabase/functions/auth/verify-wallet/index.ts
```typescript
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { generateJWT } from '../../_shared/utils/jwt.ts'

const supabase = createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
)

serve(async (req) => {
  if (req.method !== 'POST') {
    return new Response('Method not allowed', { status: 405 })
  }
  
  try {
    const { walletAddress, signature, message } = await req.json()
    
    // Verify signature (implementation depends on your crypto library)
    // This is a placeholder - you'd implement proper Ethereum signature verification
    const isValidSignature = true // Replace with actual verification
    
    if (!isValidSignature) {
      return new Response(JSON.stringify({ error: 'Invalid signature' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' }
      })
    }
    
    // Check if user exists in profiles table
    const { data: profile } = await supabase
      .from('profiles')
      .select('*')
      .eq('wallet_address', walletAddress)
      .single()
    
    // Generate JWT
    const token = generateJWT({ wallet_address: walletAddress })
    
    return new Response(JSON.stringify({
      token,
      profile: profile || null,
      isNewUser: !profile
    }), {
      headers: { 'Content-Type': 'application/json' }
    })
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
})
```

### supabase/functions/designs/upload-files/index.ts
```typescript
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { pinFileToIPFS } from '../../_shared/utils/ipfs.ts'
import { authMiddleware, AuthenticatedRequest } from '../../_shared/middleware/auth.ts'

serve(async (req: Request) => {
  // Handle authentication
  const authError = await authMiddleware(req)
  if (authError) return authError
  
  if (req.method !== 'POST') {
    return new Response('Method not allowed', { status: 405 })
  }
  
  try {
    const formData = await req.formData()
    const cadFile = formData.get('cadFile') as File
    const previewFile = formData.get('previewFile') as File
    
    if (!cadFile || !previewFile) {
      return new Response(JSON.stringify({ error: 'Both CAD and preview files required' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      })
    }
    
    // Validate file types
    const allowedCadTypes = ['application/zip', 'application/x-zip-compressed']
    const allowedImageTypes = ['image/png', 'image/jpeg', 'image/webp']
    
    if (!allowedCadTypes.includes(cadFile.type)) {
      return new Response(JSON.stringify({ error: 'CAD file must be a ZIP archive' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      })
    }
    
    if (!allowedImageTypes.includes(previewFile.type)) {
      return new Response(JSON.stringify({ error: 'Preview file must be PNG, JPG, or WebP' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      })
    }
    
    // Validate file sizes (50MB limit)
    const maxSize = 50 * 1024 * 1024
    if (cadFile.size > maxSize || previewFile.size > maxSize) {
      return new Response(JSON.stringify({ error: 'Files must be smaller than 50MB' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      })
    }
    
    // Upload files to IPFS
    const [cadResult, previewResult] = await Promise.all([
      pinFileToIPFS(cadFile, `cad-${Date.now()}`),
      pinFileToIPFS(previewFile, `preview-${Date.now()}`)
    ])
    
    return new Response(JSON.stringify({
      cadZipCid: cadResult.IpfsHash,
      previewCid: previewResult.IpfsHash,
      cadSize: cadResult.PinSize,
      previewSize: previewResult.PinSize
    }), {
      headers: { 'Content-Type': 'application/json' }
    })
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    })
  }
})
```

## Step 7: Environment Variables

Create `.env.example` in the backend directory:

```env
# Supabase Configuration
SUPABASE_URL=your_supabase_project_url
SUPABASE_SERVICE_ROLE_KEY=your_supabase_service_role_key
SUPABASE_ANON_KEY=your_supabase_anon_key

# Pinata Configuration
PINATA_API_KEY=your_pinata_api_key
PINATA_SECRET_KEY=your_pinata_secret_key

# JWT Configuration
JWT_SECRET=your_jwt_secret_key_at_least_32_characters_long

# Blockchain Configuration
RPC_BASE_SEPOLIA=your_base_sepolia_rpc_url
CONTRACT_ADDRESS=your_deployed_contract_address
```

## Step 8: Local Development

```bash
# Start local Supabase
supabase start

# Deploy functions locally
supabase functions serve --env-file .env

# Test functions
curl -X POST http://localhost:54321/functions/v1/auth/verify-wallet \
  -H "Content-Type: application/json" \
  -d '{"walletAddress":"0x1234...","signature":"0x...","message":"Login to CosmiFi"}'
```

## Step 9: Deployment

```bash
# Deploy all functions
supabase functions deploy

# Deploy specific function
supabase functions deploy designs/upload-files

# Set secrets
supabase secrets set PINATA_API_KEY=your_key
supabase secrets set PINATA_SECRET_KEY=your_secret
supabase secrets set JWT_SECRET=your_jwt_secret
```

This implementation guide provides a solid foundation for building the Supabase Edge Functions backend for CosmiFi. The code examples cover authentication, file uploads, IPFS integration, and database operations.